{"version":3,"file":"default-src_app_core_data_metadata-field-data_service_ts.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEsC;AAEa;AACqC;AAEH;AAClB;AACA;AAGC;AAKxC;AAIA;AAC+C;AAIlD;AAIG;AACgC;AAGT;;;;;;;AAEnD;;;AAIM,MAAOc,wBAAyB,SAAQL,oFAAsC;EASlFM,YACYC,cAA8B,EAC9BC,UAAkC,EAClCC,WAA+B,EAC/BC,UAA8B,EAC9BC,oBAA0C;IAEpD,KAAK,CAAC,gBAAgB,EAAEJ,cAAc,EAAEC,UAAU,EAAEC,WAAW,EAAEC,UAAU,CAAC;IANlE,KAAAH,cAAc,GAAdA,cAAc;IACd,KAAAC,UAAU,GAAVA,UAAU;IACV,KAAAC,WAAW,GAAXA,WAAW;IACX,KAAAC,UAAU,GAAVA,UAAU;IACV,KAAAC,oBAAoB,GAApBA,oBAAoB;IARtB,KAAAC,sBAAsB,GAAG,UAAU;IACnC,KAAAC,yBAAyB,GAAG,aAAa;IAWjD,IAAI,CAACC,UAAU,GAAG,IAAIhB,6DAAc,CAAC,IAAI,CAACiB,QAAQ,EAAER,cAAc,EAAEC,UAAU,EAAEC,WAAW,EAAEC,UAAU,EAAEC,oBAAoB,EAAE,IAAI,CAACK,gBAAgB,CAAC;IACrJ,IAAI,CAACC,UAAU,GAAG,IAAIf,8DAAc,CAAC,IAAI,CAACa,QAAQ,EAAER,cAAc,EAAEC,UAAU,EAAEC,WAAW,EAAEC,UAAU,EAAE,IAAI,CAACM,gBAAgB,CAAC;IAC/H,IAAI,CAACE,OAAO,GAAG,IAAIjB,uDAAW,CAAC,IAAI,CAACc,QAAQ,EAAER,cAAc,EAAEC,UAAU,EAAEC,WAAW,EAAEC,UAAU,EAAE,IAAI,CAACM,gBAAgB,CAAC;IACzH,IAAI,CAACG,UAAU,GAAG,IAAIpB,6DAAc,CAAC,IAAI,CAACgB,QAAQ,EAAER,cAAc,EAAEC,UAAU,EAAEC,WAAW,EAAEC,UAAU,EAAEC,oBAAoB,EAAE,IAAI,CAACK,gBAAgB,EAAE,IAAI,CAACI,mBAAmB,CAAC;EACjL;EAEA;;;;;;;;;;;EAWAC,YAAYA,CAACC,MAAsB,EAAEC,OAAA,GAA2B,EAAE,EAAEC,2BAA2B,GAAG,IAAI,EAAEC,gBAAgB,GAAG,IAAI,EAAE,GAAGC,aAAgD;IAClL,MAAMC,iBAAiB,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI1B,sEAAe,EAAE,EAAEoB,OAAO,EAAE;MACtEO,YAAY,EAAE,CAAC,IAAInC,2EAAY,CAAC,QAAQ,EAAE2B,MAAM,CAACS,MAAM,CAAC;KACzD,CAAC;IACF,OAAO,IAAI,CAACC,QAAQ,CAAC,IAAI,CAACpB,sBAAsB,EAAEe,iBAAiB,EAAEH,2BAA2B,EAAEC,gBAAgB,EAAE,GAAGC,aAAa,CAAC;EACvI;EAEA;;;;;;;;;;;;;;;;EAgBAO,uBAAuBA,CAACX,MAAc,EAAEY,OAAe,EAAEC,SAAiB,EAAEC,KAAa,EAAEC,SAAiB,EAAEd,OAAA,GAA2B,EAAE,EAAEC,2BAA2B,GAAG,IAAI,EAAEC,gBAAgB,GAAG,IAAI,EAAE,GAAGC,aAAgD;IAC3P,MAAMY,YAAY,GAAGV,MAAM,CAACC,MAAM,CAAC,IAAI1B,sEAAe,EAAE,EAAEoB,OAAO,EAAE;MACjEO,YAAY,EAAE,CACZ,IAAInC,2EAAY,CAAC,QAAQ,EAAEH,4DAAQ,CAAC8B,MAAM,CAAC,GAAGA,MAAM,GAAG,EAAE,CAAC,EAC1D,IAAI3B,2EAAY,CAAC,SAAS,EAAEH,4DAAQ,CAAC0C,OAAO,CAAC,GAAGA,OAAO,GAAG,EAAE,CAAC,EAC7D,IAAIvC,2EAAY,CAAC,WAAW,EAAEH,4DAAQ,CAAC2C,SAAS,CAAC,GAAGA,SAAS,GAAG,EAAE,CAAC,EACnE,IAAIxC,2EAAY,CAAC,OAAO,EAAEH,4DAAQ,CAAC4C,KAAK,CAAC,GAAGA,KAAK,GAAG,EAAE,CAAC,EACvD,IAAIzC,2EAAY,CAAC,WAAW,EAAEH,4DAAQ,CAAC6C,SAAS,CAAC,GAAGA,SAAS,GAAG,EAAE,CAAC;KAEtE,CAAC;IACF,OAAO,IAAI,CAACL,QAAQ,CAAC,IAAI,CAACnB,yBAAyB,EAAEyB,YAAY,EAAEd,2BAA2B,EAAEC,gBAAgB,EAAE,GAAGC,aAAa,CAAC;EACrI;EAEA;;;;;;EAMAa,oBAAoBA,CAACC,cAAsB;IACzC,OAAO,IAAI,CAACP,uBAAuB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAEO,cAAc,EAAE,IAAI,CAAC;EACnF;EAEA;;;;EAIAC,aAAaA,CAAA;IACX,IAAI,CAACC,iBAAiB,EAAE,CAACC,IAAI,CAACpD,qDAAI,CAAC,CAAC,CAAC,CAAC,CAACqD,SAAS,CAAEC,IAAY,IAAI;MAChE,IAAI,CAACtC,cAAc,CAACuC,uBAAuB,CAACD,IAAI,CAAC;IACnD,CAAC,CAAC;EAEJ;EAGA;;;;;;;;EAQAE,MAAMA,CAACC,QAAgB,EAAEC,mBAA8B;IACrD,OAAO,IAAI,CAAC9B,UAAU,CAAC4B,MAAM,CAACC,QAAQ,EAAEC,mBAAmB,CAAC;EAC9D;EAEA;;;;;;;;;EASOC,YAAYA,CAACL,IAAY,EAAEI,mBAA8B;IAC9D,OAAO,IAAI,CAAC9B,UAAU,CAAC+B,YAAY,CAACL,IAAI,EAAEI,mBAAmB,CAAC;EAChE;EAEA;;;;;EAKAE,GAAGA,CAACC,MAAqB;IACvB,OAAO,IAAI,CAAClC,OAAO,CAACiC,GAAG,CAACC,MAAM,CAAC;EACjC;EAEA;;;;;;EAMAC,MAAMA,CAACD,MAAqB,EAAE,GAAGE,MAAsB;IACrD,OAAO,IAAI,CAACxC,UAAU,CAACuC,MAAM,CAACD,MAAM,EAAE,GAAGE,MAAM,CAAC;EAClD;EAEA;;;;;;;;;;;;;;EAcOtB,QAAQA,CAACuB,YAAoB,EAAEhC,OAAyB,EAAEC,2BAAqC,EAAEC,gBAA0B,EAAE,GAAGC,aAAgD;IACrL,OAAO,IAAI,CAACT,UAAU,CAACe,QAAQ,CAACuB,YAAY,EAAEhC,OAAO,EAAEC,2BAA2B,EAAEC,gBAAgB,EAAE,GAAGC,aAAa,CAAC;EACzH;;;uBAzJWrB,wBAAwB,EAAAmD,uDAAA,CAAAE,6DAAA,GAAAF,uDAAA,CAAAG,6FAAA,GAAAH,uDAAA,CAAAI,2EAAA,GAAAJ,uDAAA,CAAAK,4EAAA,GAAAL,uDAAA,CAAAM,6FAAA;IAAA;EAAA;;;aAAxBzD,wBAAwB;MAAA0D,OAAA,EAAxB1D,wBAAwB,CAAA2D,IAAA;MAAAC,UAAA,EADX;IAAM;EAAA","sources":["./src/app/core/data/metadata-field-data.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nimport { hasValue } from '../../shared/empty.util';\nimport { NotificationsService } from '../../shared/notifications/notifications.service';\nimport { FollowLinkConfig } from '../../shared/utils/follow-link-config.model';\nimport { RemoteDataBuildService } from '../cache/builders/remote-data-build.service';\nimport { RequestParam } from '../cache/models/request-param.model';\nimport { ObjectCacheService } from '../cache/object-cache.service';\nimport { MetadataField } from '../metadata/metadata-field.model';\nimport { MetadataSchema } from '../metadata/metadata-schema.model';\nimport { HALEndpointService } from '../shared/hal-endpoint.service';\nimport { NoContent } from '../shared/NoContent.model';\nimport {\n  CreateData,\n  CreateDataImpl,\n} from './base/create-data';\nimport {\n  DeleteData,\n  DeleteDataImpl,\n} from './base/delete-data';\nimport { IdentifiableDataService } from './base/identifiable-data.service';\nimport {\n  PutData,\n  PutDataImpl,\n} from './base/put-data';\nimport {\n  SearchData,\n  SearchDataImpl,\n} from './base/search-data';\nimport { FindListOptions } from './find-list-options.model';\nimport { PaginatedList } from './paginated-list.model';\nimport { RemoteData } from './remote-data';\nimport { RequestService } from './request.service';\n\n/**\n * A service responsible for fetching/sending data from/to the REST API on the metadatafields endpoint\n */\n@Injectable({ providedIn: 'root' })\nexport class MetadataFieldDataService extends IdentifiableDataService<MetadataField> implements CreateData<MetadataField>, PutData<MetadataField>, DeleteData<MetadataField>, SearchData<MetadataField> {\n  private createData: CreateData<MetadataField>;\n  private searchData: SearchData<MetadataField>;\n  private putData: PutData<MetadataField>;\n  private deleteData: DeleteData<MetadataField>;\n\n  protected searchBySchemaLinkPath = 'bySchema';\n  protected searchByFieldNameLinkPath = 'byFieldName';\n\n  constructor(\n    protected requestService: RequestService,\n    protected rdbService: RemoteDataBuildService,\n    protected objectCache: ObjectCacheService,\n    protected halService: HALEndpointService,\n    protected notificationsService: NotificationsService,\n  ) {\n    super('metadatafields', requestService, rdbService, objectCache, halService);\n\n    this.createData = new CreateDataImpl(this.linkPath, requestService, rdbService, objectCache, halService, notificationsService, this.responseMsToLive);\n    this.searchData = new SearchDataImpl(this.linkPath, requestService, rdbService, objectCache, halService, this.responseMsToLive);\n    this.putData = new PutDataImpl(this.linkPath, requestService, rdbService, objectCache, halService, this.responseMsToLive);\n    this.deleteData = new DeleteDataImpl(this.linkPath, requestService, rdbService, objectCache, halService, notificationsService, this.responseMsToLive, this.constructIdEndpoint);\n  }\n\n  /**\n   * Find metadata fields belonging to a metadata schema\n   * @param schema                      The metadata schema to list fields for\n   * @param options                     The options info used to retrieve the fields\n   * @param useCachedVersionIfAvailable If this is true, the request will only be sent if there's\n   *                                    no valid cached version. Defaults to true\n   * @param reRequestOnStale            Whether or not the request should automatically be re-\n   *                                    requested after the response becomes stale\n   * @param linksToFollow               List of {@link FollowLinkConfig} that indicate which\n   *                                    {@link HALLink}s should be automatically resolved\n   */\n  findBySchema(schema: MetadataSchema, options: FindListOptions = {}, useCachedVersionIfAvailable = true, reRequestOnStale = true, ...linksToFollow: FollowLinkConfig<MetadataField>[]) {\n    const optionsWithSchema = Object.assign(new FindListOptions(), options, {\n      searchParams: [new RequestParam('schema', schema.prefix)],\n    });\n    return this.searchBy(this.searchBySchemaLinkPath, optionsWithSchema, useCachedVersionIfAvailable, reRequestOnStale, ...linksToFollow);\n  }\n\n  /**\n   * Find metadata fields with either the partial metadata field name (e.g. \"dc.ti\") as query or an exact match to\n   * at least the schema, element or qualifier\n   * @param schema    optional; an exact match of the prefix of the metadata schema (e.g. \"dc\", \"dcterms\", \"eperson\")\n   * @param element   optional; an exact match of the field's element (e.g. \"contributor\", \"title\")\n   * @param qualifier optional; an exact match of the field's qualifier (e.g. \"author\", \"alternative\")\n   * @param query     optional (if any of schema, element or qualifier used) - part of the fully qualified field,\n   * should start with the start of the schema, element or qualifier (e.g. “dc.ti”, “contributor”, “auth”, “contributor.ot”)\n   * @param exactName optional; the exact fully qualified field, should use the syntax schema.element.qualifier or\n   * schema.element if no qualifier exists (e.g. \"dc.title\", \"dc.contributor.author\"). It will only return one value\n   * if there's an exact match\n   * @param options   The options info used to retrieve the fields\n   * @param useCachedVersionIfAvailable If this is true, the request will only be sent if there's no valid cached version. Defaults to true\n   * @param reRequestOnStale  Whether or not the request should automatically be re-requested after the response becomes stale\n   * @param linksToFollow List of {@link FollowLinkConfig} that indicate which {@link HALLink}s should be automatically resolved\n   */\n  searchByFieldNameParams(schema: string, element: string, qualifier: string, query: string, exactName: string, options: FindListOptions = {}, useCachedVersionIfAvailable = true, reRequestOnStale = true, ...linksToFollow: FollowLinkConfig<MetadataField>[]): Observable<RemoteData<PaginatedList<MetadataField>>> {\n    const optionParams = Object.assign(new FindListOptions(), options, {\n      searchParams: [\n        new RequestParam('schema', hasValue(schema) ? schema : ''),\n        new RequestParam('element', hasValue(element) ? element : ''),\n        new RequestParam('qualifier', hasValue(qualifier) ? qualifier : ''),\n        new RequestParam('query', hasValue(query) ? query : ''),\n        new RequestParam('exactName', hasValue(exactName) ? exactName : ''),\n      ],\n    });\n    return this.searchBy(this.searchByFieldNameLinkPath, optionParams, useCachedVersionIfAvailable, reRequestOnStale, ...linksToFollow);\n  }\n\n  /**\n   * Finds a specific metadata field by name.\n   * @param exactFieldName  The exact fully qualified field, should use the syntax schema.element.qualifier or\n   * schema.element if no qualifier exists (e.g. \"dc.title\", \"dc.contributor.author\"). It will only return one value\n   * if there's an exact match, empty list if there is no exact match.\n   */\n  findByExactFieldName(exactFieldName: string): Observable<RemoteData<PaginatedList<MetadataField>>> {\n    return this.searchByFieldNameParams(null, null, null, null, exactFieldName, null);\n  }\n\n  /**\n   * Clear all metadata field requests\n   * Used for refreshing lists after adding/updating/removing a metadata field from a metadata schema\n   */\n  clearRequests(): void {\n    this.getBrowseEndpoint().pipe(take(1)).subscribe((href: string) => {\n      this.requestService.setStaleByHrefSubstring(href);\n    });\n\n  }\n\n\n  /**\n   * Delete an existing object on the server\n   * @param   objectId The id of the object to be removed\n   * @param   copyVirtualMetadata (optional parameter) the identifiers of the relationship types for which the virtual\n   *                            metadata should be saved as real metadata\n   * @return  A RemoteData observable with an empty payload, but still representing the state of the request: statusCode,\n   *          errorMessage, timeCompleted, etc\n   */\n  delete(objectId: string, copyVirtualMetadata?: string[]): Observable<RemoteData<NoContent>> {\n    return this.deleteData.delete(objectId, copyVirtualMetadata);\n  }\n\n  /**\n   * Delete an existing object on the server\n   * @param   href The self link of the object to be removed\n   * @param   copyVirtualMetadata (optional parameter) the identifiers of the relationship types for which the virtual\n   *                            metadata should be saved as real metadata\n   * @return  A RemoteData observable with an empty payload, but still representing the state of the request: statusCode,\n   *          errorMessage, timeCompleted, etc\n   *          Only emits once all request related to the DSO has been invalidated.\n   */\n  public deleteByHref(href: string, copyVirtualMetadata?: string[]): Observable<RemoteData<NoContent>> {\n    return this.deleteData.deleteByHref(href, copyVirtualMetadata);\n  }\n\n  /**\n   * Send a PUT request for the specified object\n   *\n   * @param object The object to send a put request for.\n   */\n  put(object: MetadataField): Observable<RemoteData<MetadataField>> {\n    return this.putData.put(object);\n  }\n\n  /**\n   * Create a new object on the server, and store the response in the object cache\n   *\n   * @param object    The object to create\n   * @param params    Array with additional params to combine with query string\n   */\n  create(object: MetadataField, ...params: RequestParam[]): Observable<RemoteData<MetadataField>> {\n    return this.createData.create(object, ...params);\n  }\n\n  /**\n   * Make a new FindListRequest with given search method\n   *\n   * @param searchMethod                The search method for the object\n   * @param options                     The [[FindListOptions]] object\n   * @param useCachedVersionIfAvailable If this is true, the request will only be sent if there's\n   *                                    no valid cached version. Defaults to true\n   * @param reRequestOnStale            Whether or not the request should automatically be re-\n   *                                    requested after the response becomes stale\n   * @param linksToFollow               List of {@link FollowLinkConfig} that indicate which\n   *                                    {@link HALLink}s should be automatically resolved\n   * @return {Observable<RemoteData<PaginatedList<T>>}\n   *    Return an observable that emits response from the server\n   */\n  public searchBy(searchMethod: string, options?: FindListOptions, useCachedVersionIfAvailable?: boolean, reRequestOnStale?: boolean, ...linksToFollow: FollowLinkConfig<MetadataField>[]): Observable<RemoteData<PaginatedList<MetadataField>>> {\n    return this.searchData.searchBy(searchMethod, options, useCachedVersionIfAvailable, reRequestOnStale, ...linksToFollow);\n  }\n\n}\n"],"names":["take","hasValue","NotificationsService","RemoteDataBuildService","RequestParam","ObjectCacheService","HALEndpointService","CreateDataImpl","DeleteDataImpl","IdentifiableDataService","PutDataImpl","SearchDataImpl","FindListOptions","RequestService","MetadataFieldDataService","constructor","requestService","rdbService","objectCache","halService","notificationsService","searchBySchemaLinkPath","searchByFieldNameLinkPath","createData","linkPath","responseMsToLive","searchData","putData","deleteData","constructIdEndpoint","findBySchema","schema","options","useCachedVersionIfAvailable","reRequestOnStale","linksToFollow","optionsWithSchema","Object","assign","searchParams","prefix","searchBy","searchByFieldNameParams","element","qualifier","query","exactName","optionParams","findByExactFieldName","exactFieldName","clearRequests","getBrowseEndpoint","pipe","subscribe","href","setStaleByHrefSubstring","delete","objectId","copyVirtualMetadata","deleteByHref","put","object","create","params","searchMethod","i0","ɵɵinject","i1","i2","i3","i4","i5","factory","ɵfac","providedIn"],"sourceRoot":"webpack:///","x_google_ignoreList":[]}