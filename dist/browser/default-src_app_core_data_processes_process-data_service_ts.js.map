{"version":3,"file":"default-src_app_core_data_processes_process-data_service_ts.js","mappings":"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","sources":["./src/app/core/data/processes/process-data.service.ts"],"sourcesContent":["import {\n  Inject,\n  Injectable,\n  InjectionToken,\n  NgZone,\n} from '@angular/core';\nimport {\n  Observable,\n  Subscription,\n} from 'rxjs';\nimport {\n  distinctUntilChanged,\n  filter,\n  find,\n  switchMap,\n} from 'rxjs/operators';\nimport { ProcessStatus } from 'src/app/process-page/processes/process-status.model';\n\nimport { Process } from '../../../process-page/processes/process.model';\nimport { hasValue } from '../../../shared/empty.util';\nimport { NotificationsService } from '../../../shared/notifications/notifications.service';\nimport { FollowLinkConfig } from '../../../shared/utils/follow-link-config.model';\nimport { RemoteDataBuildService } from '../../cache/builders/remote-data-build.service';\nimport { ObjectCacheService } from '../../cache/object-cache.service';\nimport { Bitstream } from '../../shared/bitstream.model';\nimport { HALEndpointService } from '../../shared/hal-endpoint.service';\nimport { NoContent } from '../../shared/NoContent.model';\nimport { getAllCompletedRemoteData } from '../../shared/operators';\nimport {\n  DeleteData,\n  DeleteDataImpl,\n} from '../base/delete-data';\nimport {\n  FindAllData,\n  FindAllDataImpl,\n} from '../base/find-all-data';\nimport { IdentifiableDataService } from '../base/identifiable-data.service';\nimport {\n  SearchData,\n  SearchDataImpl,\n} from '../base/search-data';\nimport { BitstreamDataService } from '../bitstream-data.service';\nimport { FindListOptions } from '../find-list-options.model';\nimport { PaginatedList } from '../paginated-list.model';\nimport { RemoteData } from '../remote-data';\nimport { RequestService } from '../request.service';\n\n/**\n * Create an InjectionToken for the default JS setTimeout function, purely so we can mock it during\n * testing. (fakeAsync isn't working for this case)\n */\nexport const TIMER_FACTORY = new InjectionToken<(callback: (...args: any[]) => void, ms?: number, ...args: any[]) => NodeJS.Timeout>('timer', {\n  providedIn: 'root',\n  factory: () => setTimeout,\n});\n\n@Injectable({ providedIn: 'root' })\nexport class ProcessDataService extends IdentifiableDataService<Process> implements FindAllData<Process>, DeleteData<Process>, SearchData<Process> {\n  private findAllData: FindAllData<Process>;\n  private deleteData: DeleteData<Process>;\n  private searchData: SearchData<Process>;\n  protected activelyBeingPolled: Map<string, NodeJS.Timeout> = new Map();\n  protected subs: Map<string, Subscription> = new Map();\n\n  constructor(\n    protected requestService: RequestService,\n    protected rdbService: RemoteDataBuildService,\n    protected objectCache: ObjectCacheService,\n    protected halService: HALEndpointService,\n    protected bitstreamDataService: BitstreamDataService,\n    protected notificationsService: NotificationsService,\n    protected zone: NgZone,\n    @Inject(TIMER_FACTORY) protected timer: (callback: (...args: any[]) => void, ms?: number, ...args: any[]) => NodeJS.Timeout,\n  ) {\n    super('processes', requestService, rdbService, objectCache, halService);\n\n    this.findAllData = new FindAllDataImpl(this.linkPath, requestService, rdbService, objectCache, halService, this.responseMsToLive);\n    this.deleteData = new DeleteDataImpl(this.linkPath, requestService, rdbService, objectCache, halService, notificationsService, this.responseMsToLive, this.constructIdEndpoint);\n    this.searchData = new SearchDataImpl(this.linkPath, requestService, rdbService, objectCache, halService, this.responseMsToLive);\n  }\n\n  /**\n   * Return true if the given process has the given status\n   * @protected\n   */\n  protected static statusIs(process: Process, status: ProcessStatus): boolean {\n    return hasValue(process) && process.processStatus === status;\n  }\n\n  /**\n   * Return true if the given process has the status COMPLETED or FAILED\n   */\n  public static hasCompletedOrFailed(process: Process): boolean {\n    return ProcessDataService.statusIs(process, ProcessStatus.COMPLETED) ||\n      ProcessDataService.statusIs(process, ProcessStatus.FAILED);\n  }\n\n  /**\n   * Get the endpoint for the files of the process\n   * @param processId The ID of the process\n   */\n  getFilesEndpoint(processId: string): Observable<string> {\n    return this.getBrowseEndpoint().pipe(\n      switchMap((href) => this.halService.getEndpoint('files', `${href}/${processId}`)),\n    );\n  }\n\n  /**\n   * Get a process' output files\n   * @param processId The ID of the process\n   */\n  getFiles(processId: string): Observable<RemoteData<PaginatedList<Bitstream>>> {\n    const href$ = this.getFilesEndpoint(processId);\n    return this.bitstreamDataService.findListByHref(href$);\n  }\n\n  /**\n   * Returns {@link RemoteData} of all object with a list of {@link FollowLinkConfig}, to indicate which embedded\n   * info should be added to the objects\n   *\n   * @param options                     Find list options object\n   * @param useCachedVersionIfAvailable If this is true, the request will only be sent if there's\n   *                                    no valid cached version. Defaults to true\n   * @param reRequestOnStale            Whether or not the request should automatically be re-\n   *                                    requested after the response becomes stale\n   * @param linksToFollow               List of {@link FollowLinkConfig} that indicate which\n   *                                    {@link HALLink}s should be automatically resolved\n   * @return {Observable<RemoteData<PaginatedList<T>>>}\n   *    Return an observable that emits object list\n   */\n  findAll(options?: FindListOptions, useCachedVersionIfAvailable?: boolean, reRequestOnStale?: boolean, ...linksToFollow: FollowLinkConfig<Process>[]): Observable<RemoteData<PaginatedList<Process>>> {\n    return this.findAllData.findAll(options, useCachedVersionIfAvailable, reRequestOnStale, ...linksToFollow);\n  }\n\n  /**\n   * @param searchMethod                The search method for the Process\n   * @param options                     The FindListOptions object\n   * @param useCachedVersionIfAvailable If this is true, the request will only be sent if there's\n   *                                    no valid cached version. Defaults to true.\n   * @param reRequestOnStale            Whether the request should automatically be re-\n   *                                    requested after the response becomes stale.\n   * @param linksToFollow               List of {@link FollowLinkConfig} that indicate which\n   *                                    {@link HALLink}s should automatically be resolved.\n   * @return {Observable<RemoteData<PaginatedList<Process>>>}\n   *    Return an observable that emits a paginated list of processes\n   */\n  searchBy(searchMethod: string, options?: FindListOptions, useCachedVersionIfAvailable?: boolean, reRequestOnStale?: boolean, ...linksToFollow: FollowLinkConfig<Process>[]): Observable<RemoteData<PaginatedList<Process>>> {\n    return this.searchData.searchBy(searchMethod, options, useCachedVersionIfAvailable, reRequestOnStale, ...linksToFollow);\n  }\n\n  /**\n   * @param id                          The id for this auto-refreshing search. Used to stop\n   *                                    auto-refreshing afterwards, and ensure we're not\n   *                                    auto-refreshing the same thing multiple times.\n   * @param searchMethod                The search method for the Process\n   * @param options                     The FindListOptions object\n   * @param pollingIntervalInMs         The interval by which the search will be repeated\n   * @param linksToFollow               List of {@link FollowLinkConfig} that indicate which\n   *                                    {@link HALLink}s should automatically be resolved.\n   * @return {Observable<RemoteData<PaginatedList<Process>>>}\n   *    Return an observable that emits a paginated list of processes every interval\n   */\n  autoRefreshingSearchBy(id: string, searchMethod: string, options?: FindListOptions, pollingIntervalInMs: number = 5000, ...linksToFollow: FollowLinkConfig<Process>[]): Observable<RemoteData<PaginatedList<Process>>> {\n\n    const result$ = this.searchBy(searchMethod, options, true, true, ...linksToFollow).pipe(\n      getAllCompletedRemoteData(),\n    );\n\n    const sub = result$.pipe(\n      filter(() =>\n        !this.activelyBeingPolled.has(id),\n      ),\n    ).subscribe((processListRd: RemoteData<PaginatedList<Process>>) => {\n      this.clearCurrentTimeout(id);\n      const nextTimeout = this.timer(() => {\n        this.activelyBeingPolled.delete(id);\n        this.requestService.setStaleByHrefSubstring(processListRd.payload._links.self.href);\n      }, pollingIntervalInMs);\n\n      this.activelyBeingPolled.set(id, nextTimeout);\n    });\n\n    this.subs.set(id, sub);\n\n    return result$;\n  }\n\n  /**\n   * Stop auto-refreshing the request with the given id\n   * @param id the id of the request to stop automatically refreshing\n   */\n  stopAutoRefreshing(id: string) {\n    this.clearCurrentTimeout(id);\n    if (hasValue(this.subs.get(id))) {\n      this.subs.get(id).unsubscribe();\n      this.subs.delete(id);\n    }\n  }\n\n  /**\n   * Delete an existing object on the server\n   * @param   objectId The id of the object to be removed\n   * @param   copyVirtualMetadata (optional parameter) the identifiers of the relationship types for which the virtual\n   *                            metadata should be saved as real metadata\n   * @return  A RemoteData observable with an empty payload, but still representing the state of the request: statusCode,\n   *          errorMessage, timeCompleted, etc\n   */\n  public delete(objectId: string, copyVirtualMetadata?: string[]): Observable<RemoteData<NoContent>> {\n    return this.deleteData.delete(objectId, copyVirtualMetadata);\n  }\n\n  /**\n   * Delete an existing object on the server\n   * @param   href The self link of the object to be removed\n   * @param   copyVirtualMetadata (optional parameter) the identifiers of the relationship types for which the virtual\n   *                            metadata should be saved as real metadata\n   * @return  A RemoteData observable with an empty payload, but still representing the state of the request: statusCode,\n   *          errorMessage, timeCompleted, etc\n   *          Only emits once all request related to the DSO has been invalidated.\n   */\n  public deleteByHref(href: string, copyVirtualMetadata?: string[]): Observable<RemoteData<NoContent>> {\n    return this.deleteData.deleteByHref(href, copyVirtualMetadata);\n  }\n\n  /**\n   * Clear the timeout for the given id, if that timeout exists\n   * @protected\n   */\n  protected clearCurrentTimeout(id: string): void {\n    const timeout = this.activelyBeingPolled.get(id);\n    if (hasValue(timeout)) {\n      clearTimeout(timeout);\n    }\n    this.activelyBeingPolled.delete(id);\n  }\n\n  /**\n   * Poll the process with the given ID, using the given interval, until that process either\n   * completes successfully or fails\n   *\n   * Return an Observable<RemoteData> for the Process. Note that this will also emit while the\n   * process is still running. It will only emit again when the process (not the RemoteData!) changes\n   * status. That makes it more convenient to retrieve that process for a component: you can replace\n   * a findByID call with this method, rather than having to do a separate findById, and then call\n   * this method\n   *\n   * @param processId           The ID of the {@link Process} to poll\n   * @param pollingIntervalInMs The interval for how often the request needs to be polled\n   * @param linksToFollow       List of {@link FollowLinkConfig} that indicate which {@link HALLink}s should be\n   *                            automatically resolved\n   */\n  public autoRefreshUntilCompletion(processId: string, pollingIntervalInMs = 5000, ...linksToFollow: FollowLinkConfig<Process>[]): Observable<RemoteData<Process>> {\n    const process$: Observable<RemoteData<Process>> = this.findById(processId, true, true, ...linksToFollow)\n      .pipe(\n        getAllCompletedRemoteData(),\n      );\n\n    // Create a subscription that marks the data as stale if the process hasn't been completed and\n    // the polling interval time has been exceeded.\n    const sub = process$.pipe(\n      filter((processRD: RemoteData<Process>) =>\n        !ProcessDataService.hasCompletedOrFailed(processRD.payload) &&\n        !this.activelyBeingPolled.has(processId),\n      ),\n    ).subscribe((processRD: RemoteData<Process>) => {\n      this.clearCurrentTimeout(processId);\n      if (processRD.hasSucceeded) {\n        const nextTimeout = this.timer(() => {\n          this.activelyBeingPolled.delete(processId);\n          this.invalidateByHref(processRD.payload._links.self.href);\n        }, pollingIntervalInMs);\n\n        this.activelyBeingPolled.set(processId, nextTimeout);\n      }\n    });\n\n    this.subs.set(processId, sub);\n\n    // When the process completes create a one off subscription (the `find` completes the\n    // observable) that unsubscribes the previous one, removes the processId from the list of\n    // processes being polled and clears any running timeouts\n    process$.pipe(\n      find((processRD: RemoteData<Process>) => ProcessDataService.hasCompletedOrFailed(processRD.payload)),\n    ).subscribe(() => {\n      this.stopAutoRefreshing(processId);\n    });\n\n    return process$.pipe(\n      distinctUntilChanged((previous: RemoteData<Process>, current: RemoteData<Process>) =>\n        previous.payload?.processStatus === current.payload?.processStatus,\n      ),\n    );\n  }\n}\n"],"names":["InjectionToken","NgZone","distinctUntilChanged","filter","find","switchMap","ProcessStatus","hasValue","NotificationsService","RemoteDataBuildService","ObjectCacheService","HALEndpointService","getAllCompletedRemoteData","DeleteDataImpl","FindAllDataImpl","IdentifiableDataService","SearchDataImpl","BitstreamDataService","RequestService","TIMER_FACTORY","providedIn","factory","setTimeout","ProcessDataService","constructor","requestService","rdbService","objectCache","halService","bitstreamDataService","notificationsService","zone","timer","activelyBeingPolled","Map","subs","findAllData","linkPath","responseMsToLive","deleteData","constructIdEndpoint","searchData","statusIs","process","status","processStatus","hasCompletedOrFailed","COMPLETED","FAILED","getFilesEndpoint","processId","getBrowseEndpoint","pipe","href","getEndpoint","getFiles","href$","findListByHref","findAll","options","useCachedVersionIfAvailable","reRequestOnStale","linksToFollow","searchBy","searchMethod","autoRefreshingSearchBy","id","pollingIntervalInMs","result$","sub","has","subscribe","processListRd","clearCurrentTimeout","nextTimeout","delete","setStaleByHrefSubstring","payload","_links","self","set","stopAutoRefreshing","get","unsubscribe","objectId","copyVirtualMetadata","deleteByHref","timeout","clearTimeout","autoRefreshUntilCompletion","process$","findById","processRD","hasSucceeded","invalidateByHref","previous","current","i0","ɵɵinject","i1","i2","i3","i4","i5","i6","ɵfac"],"sourceRoot":"webpack:///","x_google_ignoreList":[]}