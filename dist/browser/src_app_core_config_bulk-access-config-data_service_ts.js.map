{"version":3,"file":"src_app_core_config_bulk-access-config-data_service_ts.js","mappings":";;;;;;;;;;;;;;;;;;;AAEqF;AAClB;AACV;AACW;AACV;;;;;;AAE1D;;;AAIM,MAAOK,2BAA4B,SAAQD,mEAAiB;EAEhEE,YACYC,cAA8B,EAC9BC,UAAkC,EAClCC,WAA+B,EAC/BC,UAA8B;IAExC,KAAK,CAAC,4BAA4B,EAAEH,cAAc,EAAEC,UAAU,EAAEC,WAAW,EAAEC,UAAU,CAAC;IAL9E,KAAAH,cAAc,GAAdA,cAAc;IACd,KAAAC,UAAU,GAAVA,UAAU;IACV,KAAAC,WAAW,GAAXA,WAAW;IACX,KAAAC,UAAU,GAAVA,UAAU;EAGtB;;;uBATWL,2BAA2B,EAAAM,sDAAA,CAAAE,iEAAA,GAAAF,sDAAA,CAAAG,6FAAA,GAAAH,sDAAA,CAAAI,2EAAA,GAAAJ,sDAAA,CAAAK,4EAAA;IAAA;EAAA;;;aAA3BX,2BAA2B;MAAAY,OAAA,EAA3BZ,2BAA2B,CAAAa,IAAA;MAAAC,UAAA,EADd;IAAM;EAAA;;;;;;;;;;;;;;;;;;ACVK;AAG4C;AAEf;AAGlE;;;;AAIM,MAAgBf,iBAAkB,SAAQiB,yFAAqC;EACnF;;;;;;;;;;;;;;EAcOE,UAAUA,CAACC,IAAY,EAAEC,2BAA2B,GAAG,IAAI,EAAEC,gBAAgB,GAAG,IAAI,EAAE,GAAGC,aAA+C;IAC7I,OAAO,KAAK,CAACJ,UAAU,CAACC,IAAI,EAAEC,2BAA2B,EAAEC,gBAAgB,EAAE,GAAGC,aAAa,CAAC,CAACC,IAAI,CACjGN,8EAA2B,EAAE,EAC7BF,mDAAG,CAAES,EAA4B,IAAI;MACnC,IAAIA,EAAE,CAACC,SAAS,EAAE;QAChB,MAAM,IAAIC,KAAK,CAAC,8BAA8B,CAAC;MACjD,CAAC,MAAM;QACL,OAAOF,EAAE;MACX;IACF,CAAC,CAAC,CACH;EACH;EAEA;;;;;;;;;;;;;EAaOG,UAAUA,CAACC,IAAY,EAAGR,2BAA2B,GAAG,IAAI,EAAEC,gBAAgB,GAAG,IAAI,EAAE,GAAGC,aAA+C;IAC9I,OAAO,KAAK,CAACO,QAAQ,CAACD,IAAI,EAAER,2BAA2B,EAAEC,gBAAgB,EAAE,GAAGC,aAAa,CAAC;EAC9F","sources":["./src/app/core/config/bulk-access-config-data.service.ts","./src/app/core/config/config-data.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\nimport { RemoteDataBuildService } from '../cache/builders/remote-data-build.service';\nimport { ObjectCacheService } from '../cache/object-cache.service';\nimport { RequestService } from '../data/request.service';\nimport { HALEndpointService } from '../shared/hal-endpoint.service';\nimport { ConfigDataService } from './config-data.service';\n\n/**\n * Data Service responsible for retrieving Bulk Access Condition Options from the REST API\n */\n@Injectable({ providedIn: 'root' })\nexport class BulkAccessConfigDataService extends ConfigDataService {\n\n  constructor(\n    protected requestService: RequestService,\n    protected rdbService: RemoteDataBuildService,\n    protected objectCache: ObjectCacheService,\n    protected halService: HALEndpointService,\n  ) {\n    super('bulkaccessconditionoptions', requestService, rdbService, objectCache, halService);\n  }\n\n}\n","import { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { FollowLinkConfig } from '../../shared/utils/follow-link-config.model';\nimport { IdentifiableDataService } from '../data/base/identifiable-data.service';\nimport { RemoteData } from '../data/remote-data';\nimport { getFirstCompletedRemoteData } from '../shared/operators';\nimport { ConfigObject } from './models/config.model';\n\n/**\n * Abstract data service to retrieve configuration objects from the REST server.\n * Common logic for configuration objects should be implemented here.\n */\nexport abstract class ConfigDataService extends IdentifiableDataService<ConfigObject> {\n  /**\n   * Returns an observable of {@link RemoteData} of an object, based on an href, with a list of\n   * {@link FollowLinkConfig}, to automatically resolve {@link HALLink}s of the object\n   *\n   * Throws an error if a configuration object cannot be retrieved.\n   *\n   * @param href                        The url of object we want to retrieve\n   * @param useCachedVersionIfAvailable If this is true, the request will only be sent if there's\n   *                                    no valid cached version. Defaults to true\n   * @param reRequestOnStale            Whether or not the request should automatically be re-\n   *                                    requested after the response becomes stale\n   * @param linksToFollow               List of {@link FollowLinkConfig} that indicate which\n   *                                    {@link HALLink}s should be automatically resolved\n   */\n  public findByHref(href: string, useCachedVersionIfAvailable = true, reRequestOnStale = true, ...linksToFollow: FollowLinkConfig<ConfigObject>[]): Observable<RemoteData<ConfigObject>> {\n    return super.findByHref(href, useCachedVersionIfAvailable, reRequestOnStale, ...linksToFollow).pipe(\n      getFirstCompletedRemoteData(),\n      map((rd: RemoteData<ConfigObject>) => {\n        if (rd.hasFailed) {\n          throw new Error(`Couldn't retrieve the config`);\n        } else {\n          return rd;\n        }\n      }),\n    );\n  }\n\n  /**\n   * Returns a config object by given name\n   *\n   * Throws an error if a configuration object cannot be retrieved.\n   *\n   * @param name                        The name of configuration to retrieve\n   * @param useCachedVersionIfAvailable If this is true, the request will only be sent if there's\n   *                                    no valid cached version. Defaults to true\n   * @param reRequestOnStale            Whether or not the request should automatically be re-\n   *                                    requested after the response becomes stale\n   * @param linksToFollow               List of {@link FollowLinkConfig} that indicate which\n   *                                    {@link HALLink}s should be automatically resolved\n   */\n  public findByName(name: string,  useCachedVersionIfAvailable = true, reRequestOnStale = true, ...linksToFollow: FollowLinkConfig<ConfigObject>[]): Observable<RemoteData<ConfigObject>> {\n    return super.findById(name, useCachedVersionIfAvailable, reRequestOnStale, ...linksToFollow);\n  }\n}\n"],"names":["RemoteDataBuildService","ObjectCacheService","RequestService","HALEndpointService","ConfigDataService","BulkAccessConfigDataService","constructor","requestService","rdbService","objectCache","halService","i0","ɵɵinject","i1","i2","i3","i4","factory","ɵfac","providedIn","map","IdentifiableDataService","getFirstCompletedRemoteData","findByHref","href","useCachedVersionIfAvailable","reRequestOnStale","linksToFollow","pipe","rd","hasFailed","Error","findByName","name","findById"],"sourceRoot":"webpack:///","x_google_ignoreList":[]}